from fastapi import FastAPI, Request, Form
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import aiohttp
import asyncio
from typing import List, Optional
from pydantic import BaseModel
import uvicorn
import os

app = FastAPI(title="Kundenstandorte Visualisierung")

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # For production, replace with specific domains
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Get the base URL from environment variable or default to local
BASE_URL = os.getenv("VERCEL_URL", "http://localhost:8000")
if BASE_URL.startswith("http://") is False and BASE_URL.startswith("https://") is False:
    BASE_URL = f"https://{BASE_URL}"

# Mount static files
app.mount("/static", StaticFiles(directory="app/static"), name="static")

# Templates
templates = Jinja2Templates(directory="app/templates")

class Customer(BaseModel):
    kundennummer: str
    adresse: str

class GeocodingResult(BaseModel):
    kundennummer: str
    adresse: str
    lat: Optional[float] = None
    lon: Optional[float] = None
    error: Optional[str] = None

async def geocode_address(session: aiohttp.ClientSession, customer: Customer) -> GeocodingResult:
    """Geocode a single address using Nominatim API with retries and error handling"""
    max_retries = 3
    retry_delay = 1  # seconds
    
    for attempt in range(max_retries):
        try:
            encoded_address = customer.adresse.replace(' ', '+')
            url = f"https://nominatim.openstreetmap.org/search"
            params = {
                "format": "json",
                "q": customer.adresse,
                "limit": 1,
                "addressdetails": 1
            }
            headers = {
                'User-Agent': 'CustomerLocationVisualization/1.0',
                'Accept-Language': 'de,en'
            }
            
            async with session.get(url, params=params, headers=headers, timeout=10) as response:
                if response.status == 200:
                    data = await response.json()
                    if data and len(data) > 0:
                        return GeocodingResult(
                            kundennummer=customer.kundennummer,
                            adresse=customer.adresse,
                            lat=float(data[0]['lat']),
                            lon=float(data[0]['lon'])
                        )
                elif response.status == 429:  # Rate limit exceeded
                    if attempt < max_retries - 1:
                        await asyncio.sleep(retry_delay * (attempt + 1))
                        continue
                    return GeocodingResult(
                        kundennummer=customer.kundennummer,
                        adresse=customer.adresse,
                        error="Rate limit exceeded. Please try again later."
                    )
                
            return GeocodingResult(
                kundennummer=customer.kundennummer,
                adresse=customer.adresse,
                error="Adresse nicht gefunden"
            )
            
    except Exception as e:
        return GeocodingResult(
            kundennummer=customer.kundennummer,
            adresse=customer.adresse,
            error=str(e)
        )

@app.get("/")
async def home(request: Request):
    """Render the main page"""
    return templates.TemplateResponse("index.html", {"request": request})

@app.post("/geocode")
async def geocode_addresses(customers: List[Customer]):
    """Geocode multiple addresses"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for customer in customers:
            # Add delay between requests to respect rate limits
            if tasks:
                await asyncio.sleep(1)
            tasks.append(geocode_address(session, customer))
        
        results = await asyncio.gather(*tasks)
        return {"results": results}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
